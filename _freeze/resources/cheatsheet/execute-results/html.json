{
  "hash": "9160b565b8a17bcd3933ed8f20045314",
  "result": {
    "markdown": "---\ntitle: \"Gov 50 Cheat Sheet\"\nslug: cheatsheet\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(gov50data)\nlibrary(gapminder)\n```\n:::\n\n\n\n## R Basics (Week 1)\n\n### Creating a vector \n\nYou can create a vector using the `c` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Any R code that begins with the # character is a comment\n## Comments are ignored by R\n\nmy_numbers <- c(4, 8, 15, 16, 23, 42) # Anything after # is also a\n# comment\nmy_numbers\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4  8 15 16 23 42\n```\n:::\n:::\n\n\n\n### Installing and loading a package\n\nYou can install a package with the `install.packages` function, passing the name of the package to be installed as a string (that is, in quotes):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"ggplot2\")\n```\n:::\n\n\nYou can load a package into the R environment by calling `library()` with the name of package without quotes. You should only have one package per library call. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n```\n:::\n\n\n### Calling functions from specific packages\n\nWe can also use the `mypackage::` prefix to access package functions without loading:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::kable(head(mtcars))\n```\n\n::: {.cell-output-display}\n|                  |  mpg| cyl| disp|  hp| drat|    wt|  qsec| vs| am| gear| carb|\n|:-----------------|----:|---:|----:|---:|----:|-----:|-----:|--:|--:|----:|----:|\n|Mazda RX4         | 21.0|   6|  160| 110| 3.90| 2.620| 16.46|  0|  1|    4|    4|\n|Mazda RX4 Wag     | 21.0|   6|  160| 110| 3.90| 2.875| 17.02|  0|  1|    4|    4|\n|Datsun 710        | 22.8|   4|  108|  93| 3.85| 2.320| 18.61|  1|  1|    4|    1|\n|Hornet 4 Drive    | 21.4|   6|  258| 110| 3.08| 3.215| 19.44|  1|  0|    3|    1|\n|Hornet Sportabout | 18.7|   8|  360| 175| 3.15| 3.440| 17.02|  0|  0|    3|    2|\n|Valiant           | 18.1|   6|  225| 105| 2.76| 3.460| 20.22|  1|  0|    3|    1|\n:::\n:::\n\n\n## Data Visualization (Week 2)\n\n### Scatter plot\n\nYou can produce a scatter plot with using the `x` and `y` aesthetics along with the `geom_point()` function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = midwest,\n       mapping = aes(x = popdensity,\n                     y = percbelowpoverty)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](cheatsheet_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n### Smoothed curves \n\nYou can add a smoothed curve that summarizes the relationship between two variables with the `geom_smooth()` function. By default, it uses a  loess smoother to estimated the conditional mean of the y-axis variable as a function of the x-axis variable. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = midwest,\n       mapping = aes(x = popdensity,\n                     y = percbelowpoverty)) +\n  geom_point() + geom_smooth()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![](cheatsheet_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n### Adding a regression line \n\n`geom_smooth` can also add a regression line by setting the argument `method = \"lm\"` and we can turn off the shaded regions around the line with `se = FALSE`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = midwest,\n       mapping = aes(x = popdensity,\n                     y = percbelowpoverty)) +\n  geom_point() + geom_smooth(method = \"lm\", se = FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![](cheatsheet_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n### Changing the scale of the axes\n\nIf we want the scale of the x-axis to be logged to stretch out the data we can use the `scale_x_log10()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = midwest,\n       mapping = aes(x = popdensity,\n                     y = percbelowpoverty)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  scale_x_log10()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![](cheatsheet_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n### Adding informative labels to a plot\n\nUse the `labs()` to add informative labels to the plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = midwest,\n       mapping = aes(x = popdensity,\n                     y = percbelowpoverty)) +\n  geom_point() +\n  geom_smooth(method = \"loess\", se = FALSE) +\n  scale_x_log10() +\n  labs(x = \"Population Density\",\n       y = \"Percent of County Below Poverty Line\",\n       title = \"Poverty and Population Density\",\n       subtitle = \"Among Counties in the Midwest\",\n       source = \"US Census, 2000\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![](cheatsheet_files/figure-html/labels-1.png){width=672}\n:::\n:::\n\n\n### Mapping aesthetics to variables\n\nIf you would like to map an aesthetic to a variable for all geoms in the plot, you can put it in the `aes` call in the `ggplot()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = midwest,\n       mapping = aes(x = popdensity,\n                     y = percbelowpoverty,\n                     color = state,\n                     fill = state)) +\n  geom_point() +\n  geom_smooth() +\n  scale_x_log10()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![](cheatsheet_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n### Mapping aesthetics for a single geom\n\nYou can also map aesthetics for a specific geom using the `mapping` argument to that function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = midwest,\n       mapping = aes(x = popdensity,\n                     y = percbelowpoverty)) +\n  geom_point(mapping = aes(color = state)) +\n  geom_smooth(color = \"black\") +\n  scale_x_log10()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![](cheatsheet_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n### Setting the aesthetics for all observations\n\nIf you would like to set the color or size or shape of a geom for all data points (that is, not mapped to any variables), be sure to set these outside of `aes()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = midwest,\n       mapping = aes(x = popdensity,\n                     y = percbelowpoverty)) +\n  geom_point(color = \"purple\") +\n  geom_smooth() +\n  scale_x_log10()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![](cheatsheet_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n### Histograms\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = midwest,\n       mapping = aes(x = percbelowpoverty)) +\n  geom_histogram()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](cheatsheet_files/figure-html/histogram-1.png){width=672}\n:::\n:::\n\n\n\n## Data Wrangling (week 2-3)\n\n### Subsetting a data frame\n\nUse the `filter()` function from the `dplyr` package to subset a data frame.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gov50data)\n\nnews |>\n  filter(weekday == \"Tue\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 509 × 10\n   callsign affiliation date       weekday ideology national_politics\n   <chr>    <chr>       <date>     <ord>      <dbl>             <dbl>\n 1 KAEF     ABC         2017-06-13 Tue      0.0242              0.180\n 2 KBVU     FOX         2017-06-13 Tue      0.00894             0.186\n 3 KBZK     CBS         2017-06-13 Tue      0.129               0.306\n 4 KCVU     FOX         2017-06-13 Tue      0.114               0.124\n 5 KECI     NBC         2017-06-13 Tue      0.115               0.283\n 6 KHSL     CBS         2017-06-13 Tue      0.0821              0.274\n 7 KNVN     NBC         2017-06-13 Tue      0.120               0.261\n 8 KPAX     CBS         2017-06-13 Tue      0.0984              0.208\n 9 KRCR     ABC         2017-06-13 Tue      0.0187              0.206\n10 KTMF     ABC         2017-06-13 Tue      0.233               0.101\n# ℹ 499 more rows\n# ℹ 4 more variables: local_politics <dbl>, sinclair2017 <dbl>, post <dbl>,\n#   month <ord>\n```\n:::\n:::\n\n\n\nYou can filter based on multiple conditions to subset to the rows that meet all conditions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  filter(weekday == \"Tue\",\n         affiliation == \"FOX\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 70 × 10\n   callsign affiliation date       weekday ideology national_politics\n   <chr>    <chr>       <date>     <ord>      <dbl>             <dbl>\n 1 KBVU     FOX         2017-06-13 Tue      0.00894            0.186 \n 2 KCVU     FOX         2017-06-13 Tue      0.114              0.124 \n 3 WEMT     FOX         2017-06-13 Tue      0.235              0.149 \n 4 WYDO     FOX         2017-06-13 Tue      0.0949             0.182 \n 5 WEMT     FOX         2017-06-20 Tue      0.268              0.134 \n 6 WYDO     FOX         2017-06-20 Tue      0.0590             0.155 \n 7 WEMT     FOX         2017-06-27 Tue      0.0457             0.164 \n 8 WYDO     FOX         2017-06-27 Tue     -0.0588             0.147 \n 9 WEMT     FOX         2017-07-04 Tue      0.0801             0.0986\n10 WYDO     FOX         2017-07-04 Tue      0.0555             0.0910\n# ℹ 60 more rows\n# ℹ 4 more variables: local_politics <dbl>, sinclair2017 <dbl>, post <dbl>,\n#   month <ord>\n```\n:::\n:::\n\n\n\nYou can use the `|` operator to match one of two conditions (\"OR\" rather than \"AND\"):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  filter(affiliation == \"FOX\" | affiliation == \"ABC\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,033 × 10\n   callsign affiliation date       weekday  ideology national_politics\n   <chr>    <chr>       <date>     <ord>       <dbl>             <dbl>\n 1 KTMF     ABC         2017-06-07 Wed      0.0842              0.152 \n 2 KTXS     ABC         2017-06-07 Wed     -0.000488            0.0925\n 3 KAEF     ABC         2017-06-08 Thu      0.0426              0.213 \n 4 KBVU     FOX         2017-06-08 Thu     -0.0860              0.169 \n 5 KTMF     ABC         2017-06-08 Thu      0.0433              0.179 \n 6 KTXS     ABC         2017-06-08 Thu      0.0627              0.158 \n 7 WCTI     ABC         2017-06-08 Thu      0.139               0.225 \n 8 KAEF     ABC         2017-06-09 Fri      0.0870              0.153 \n 9 KTXS     ABC         2017-06-09 Fri      0.0879              0.0790\n10 WCTI     ABC         2017-06-09 Fri      0.0667              0.182 \n# ℹ 1,023 more rows\n# ℹ 4 more variables: local_politics <dbl>, sinclair2017 <dbl>, post <dbl>,\n#   month <ord>\n```\n:::\n:::\n\n\nTo test if a variable is one of several possible values, you can also use the `%in%` command:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  filter(weekday %in% c(\"Mon\", \"Fri\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,021 × 10\n   callsign affiliation date       weekday ideology national_politics\n   <chr>    <chr>       <date>     <ord>      <dbl>             <dbl>\n 1 KAEF     ABC         2017-06-09 Fri       0.0870            0.153 \n 2 KECI     NBC         2017-06-09 Fri       0.115             0.216 \n 3 KPAX     CBS         2017-06-09 Fri       0.0882            0.315 \n 4 KRBC     NBC         2017-06-09 Fri       0.0929            0.152 \n 5 KTAB     CBS         2017-06-09 Fri       0.0588            0.0711\n 6 KTXS     ABC         2017-06-09 Fri       0.0879            0.0790\n 7 WCTI     ABC         2017-06-09 Fri       0.0667            0.182 \n 8 WITN     NBC         2017-06-09 Fri      -0.0683            0.146 \n 9 WNCT     CBS         2017-06-09 Fri      -0.0181            0.126 \n10 WYDO     FOX         2017-06-09 Fri      -0.0330            0.0802\n# ℹ 1,011 more rows\n# ℹ 4 more variables: local_politics <dbl>, sinclair2017 <dbl>, post <dbl>,\n#   month <ord>\n```\n:::\n:::\n\n\nIf you want to subset to a set of specific row numbers, you can use the `slice` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## subset to the first 5 rows\nnews |>\n  slice(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 10\n  callsign affiliation date       weekday ideology national_politics\n  <chr>    <chr>       <date>     <ord>      <dbl>             <dbl>\n1 KECI     NBC         2017-06-07 Wed       0.0655            0.225 \n2 KPAX     CBS         2017-06-07 Wed       0.0853            0.283 \n3 KRBC     NBC         2017-06-07 Wed       0.0183            0.130 \n4 KTAB     CBS         2017-06-07 Wed       0.0850            0.0901\n5 KTMF     ABC         2017-06-07 Wed       0.0842            0.152 \n# ℹ 4 more variables: local_politics <dbl>, sinclair2017 <dbl>, post <dbl>,\n#   month <ord>\n```\n:::\n:::\n\n\n\nHere the `1:5` syntax tells R to produce a vector that starts at 1 and ends at 5, incrementing by 1:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\n### Filtering to the largest/smallest values of a variable\n\nTo subset to the rows that have the largest or smallest values of a given variable, use the `slice_max` and `slice_max` functions. For the largest  values, use `slice_max` and use the `n` argument to specify how many rows you want:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  slice_max(ideology, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 10\n  callsign affiliation date       weekday ideology national_politics\n  <chr>    <chr>       <date>     <ord>      <dbl>             <dbl>\n1 KAEF     ABC         2017-06-19 Mon        0.778            0.0823\n2 WYDO     FOX         2017-07-19 Wed        0.580            0.126 \n3 KRCR     ABC         2017-10-03 Tue        0.566            0.123 \n4 KAEF     ABC         2017-10-18 Wed        0.496            0.0892\n5 KBVU     FOX         2017-11-16 Thu        0.491            0.159 \n# ℹ 4 more variables: local_politics <dbl>, sinclair2017 <dbl>, post <dbl>,\n#   month <ord>\n```\n:::\n:::\n\n\nTo get lowest values, use `slice_min`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  slice_min(ideology, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 10\n  callsign affiliation date       weekday ideology national_politics\n  <chr>    <chr>       <date>     <ord>      <dbl>             <dbl>\n1 KRBC     NBC         2017-10-19 Thu       -0.674            0.0731\n2 WJHL     CBS         2017-12-08 Fri       -0.673            0.0364\n3 KRBC     NBC         2017-10-18 Wed       -0.586            0.0470\n4 KCVU     FOX         2017-06-22 Thu       -0.414            0.158 \n5 KRBC     NBC         2017-12-11 Mon       -0.365            0.0674\n# ℹ 4 more variables: local_politics <dbl>, sinclair2017 <dbl>, post <dbl>,\n#   month <ord>\n```\n:::\n:::\n\n\n\n### Sorting rows by a variable\n\nYou can sort the rows of a data set using the `arrange()` function. By default, this will sort the rows from smallest to largest. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  arrange(ideology)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,560 × 10\n   callsign affiliation date       weekday ideology national_politics\n   <chr>    <chr>       <date>     <ord>      <dbl>             <dbl>\n 1 KRBC     NBC         2017-10-19 Thu       -0.674            0.0731\n 2 WJHL     CBS         2017-12-08 Fri       -0.673            0.0364\n 3 KRBC     NBC         2017-10-18 Wed       -0.586            0.0470\n 4 KCVU     FOX         2017-06-22 Thu       -0.414            0.158 \n 5 KRBC     NBC         2017-12-11 Mon       -0.365            0.0674\n 6 KAEF     ABC         2017-06-21 Wed       -0.315            0.130 \n 7 KTMF     ABC         2017-12-01 Fri       -0.303            0.179 \n 8 KWYB     ABC         2017-12-01 Fri       -0.303            0.160 \n 9 KTVM     NBC         2017-09-01 Fri       -0.302            0.0507\n10 KNVN     NBC         2017-12-08 Fri       -0.299            0.121 \n# ℹ 2,550 more rows\n# ℹ 4 more variables: local_politics <dbl>, sinclair2017 <dbl>, post <dbl>,\n#   month <ord>\n```\n:::\n:::\n\n\nIf you would like to sort the rows from largest to smallest (descending order), you can wrap the variable name with `desc()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  arrange(desc(ideology))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,560 × 10\n   callsign affiliation date       weekday ideology national_politics\n   <chr>    <chr>       <date>     <ord>      <dbl>             <dbl>\n 1 KAEF     ABC         2017-06-19 Mon        0.778            0.0823\n 2 WYDO     FOX         2017-07-19 Wed        0.580            0.126 \n 3 KRCR     ABC         2017-10-03 Tue        0.566            0.123 \n 4 KAEF     ABC         2017-10-18 Wed        0.496            0.0892\n 5 KBVU     FOX         2017-11-16 Thu        0.491            0.159 \n 6 KTMF     ABC         2017-11-06 Mon        0.455            0.138 \n 7 KAEF     ABC         2017-06-29 Thu        0.447            0.126 \n 8 KPAX     CBS         2017-11-23 Thu        0.437            0.125 \n 9 KTAB     CBS         2017-11-16 Thu        0.427            0.0631\n10 KCVU     FOX         2017-07-06 Thu        0.406            0.154 \n# ℹ 2,550 more rows\n# ℹ 4 more variables: local_politics <dbl>, sinclair2017 <dbl>, post <dbl>,\n#   month <ord>\n```\n:::\n:::\n\n\n\n### Selecting/subsetting the columns\n\nYou can subset the data to only certain columns using the `select()` command:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  select(callsign, date, ideology)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,560 × 3\n   callsign date        ideology\n   <chr>    <date>         <dbl>\n 1 KECI     2017-06-07  0.0655  \n 2 KPAX     2017-06-07  0.0853  \n 3 KRBC     2017-06-07  0.0183  \n 4 KTAB     2017-06-07  0.0850  \n 5 KTMF     2017-06-07  0.0842  \n 6 KTXS     2017-06-07 -0.000488\n 7 KAEF     2017-06-08  0.0426  \n 8 KBVU     2017-06-08 -0.0860  \n 9 KECI     2017-06-08  0.0902  \n10 KPAX     2017-06-08  0.0668  \n# ℹ 2,550 more rows\n```\n:::\n:::\n\n\nIf you want to select a range of columns from, say, `callsign` to `ideology`, you can use the `:` operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  select(callsign:ideology)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,560 × 5\n   callsign affiliation date       weekday  ideology\n   <chr>    <chr>       <date>     <ord>       <dbl>\n 1 KECI     NBC         2017-06-07 Wed      0.0655  \n 2 KPAX     CBS         2017-06-07 Wed      0.0853  \n 3 KRBC     NBC         2017-06-07 Wed      0.0183  \n 4 KTAB     CBS         2017-06-07 Wed      0.0850  \n 5 KTMF     ABC         2017-06-07 Wed      0.0842  \n 6 KTXS     ABC         2017-06-07 Wed     -0.000488\n 7 KAEF     ABC         2017-06-08 Thu      0.0426  \n 8 KBVU     FOX         2017-06-08 Thu     -0.0860  \n 9 KECI     NBC         2017-06-08 Thu      0.0902  \n10 KPAX     CBS         2017-06-08 Thu      0.0668  \n# ℹ 2,550 more rows\n```\n:::\n:::\n\n\nYou can remove a variable from the data set by using the minus sign `-` in front of it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  select(-callsign)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,560 × 9\n   affiliation date       weekday  ideology national_politics local_politics\n   <chr>       <date>     <ord>       <dbl>             <dbl>          <dbl>\n 1 NBC         2017-06-07 Wed      0.0655              0.225          0.148 \n 2 CBS         2017-06-07 Wed      0.0853              0.283          0.123 \n 3 NBC         2017-06-07 Wed      0.0183              0.130          0.189 \n 4 CBS         2017-06-07 Wed      0.0850              0.0901         0.138 \n 5 ABC         2017-06-07 Wed      0.0842              0.152          0.129 \n 6 ABC         2017-06-07 Wed     -0.000488            0.0925         0.0791\n 7 ABC         2017-06-08 Thu      0.0426              0.213          0.228 \n 8 FOX         2017-06-08 Thu     -0.0860              0.169          0.247 \n 9 NBC         2017-06-08 Thu      0.0902              0.276          0.152 \n10 CBS         2017-06-08 Thu      0.0668              0.305          0.124 \n# ℹ 2,550 more rows\n# ℹ 3 more variables: sinclair2017 <dbl>, post <dbl>, month <ord>\n```\n:::\n:::\n\n\nYou can also drop several variables using the `c()` function or the `(a:b)` syntax:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  select(-c(callsign, date, ideology))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,560 × 7\n   affiliation weekday national_politics local_politics sinclair2017  post month\n   <chr>       <ord>               <dbl>          <dbl>        <dbl> <dbl> <ord>\n 1 NBC         Wed                0.225          0.148             1     0 Jun  \n 2 CBS         Wed                0.283          0.123             0     0 Jun  \n 3 NBC         Wed                0.130          0.189             0     0 Jun  \n 4 CBS         Wed                0.0901         0.138             0     0 Jun  \n 5 ABC         Wed                0.152          0.129             0     0 Jun  \n 6 ABC         Wed                0.0925         0.0791            1     0 Jun  \n 7 ABC         Thu                0.213          0.228             1     0 Jun  \n 8 FOX         Thu                0.169          0.247             1     0 Jun  \n 9 NBC         Thu                0.276          0.152             1     0 Jun  \n10 CBS         Thu                0.305          0.124             0     0 Jun  \n# ℹ 2,550 more rows\n```\n:::\n\n```{.r .cell-code}\nnews |>\n  select(-(callsign:ideology))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,560 × 5\n   national_politics local_politics sinclair2017  post month\n               <dbl>          <dbl>        <dbl> <dbl> <ord>\n 1            0.225          0.148             1     0 Jun  \n 2            0.283          0.123             0     0 Jun  \n 3            0.130          0.189             0     0 Jun  \n 4            0.0901         0.138             0     0 Jun  \n 5            0.152          0.129             0     0 Jun  \n 6            0.0925         0.0791            1     0 Jun  \n 7            0.213          0.228             1     0 Jun  \n 8            0.169          0.247             1     0 Jun  \n 9            0.276          0.152             1     0 Jun  \n10            0.305          0.124             0     0 Jun  \n# ℹ 2,550 more rows\n```\n:::\n:::\n\n\n\nYou can also select columns based on matching patterns in the names with functions like `starts_with()` or `ends_with()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  select(ends_with(\"politics\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,560 × 2\n   national_politics local_politics\n               <dbl>          <dbl>\n 1            0.225          0.148 \n 2            0.283          0.123 \n 3            0.130          0.189 \n 4            0.0901         0.138 \n 5            0.152          0.129 \n 6            0.0925         0.0791\n 7            0.213          0.228 \n 8            0.169          0.247 \n 9            0.276          0.152 \n10            0.305          0.124 \n# ℹ 2,550 more rows\n```\n:::\n:::\n\n\n\nThis code finds all variables with column names that end with the string \"politics\". See the [help page for `select()`](https://dplyr.tidyverse.org/reference/select.html) for more information on different ways to select. \n\n\n### Renaming a variable \n\nYou can rename a variable useing the function `rename(new_name = old_name)`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  rename(call_sign = callsign)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,560 × 10\n   call_sign affiliation date       weekday  ideology national_politics\n   <chr>     <chr>       <date>     <ord>       <dbl>             <dbl>\n 1 KECI      NBC         2017-06-07 Wed      0.0655              0.225 \n 2 KPAX      CBS         2017-06-07 Wed      0.0853              0.283 \n 3 KRBC      NBC         2017-06-07 Wed      0.0183              0.130 \n 4 KTAB      CBS         2017-06-07 Wed      0.0850              0.0901\n 5 KTMF      ABC         2017-06-07 Wed      0.0842              0.152 \n 6 KTXS      ABC         2017-06-07 Wed     -0.000488            0.0925\n 7 KAEF      ABC         2017-06-08 Thu      0.0426              0.213 \n 8 KBVU      FOX         2017-06-08 Thu     -0.0860              0.169 \n 9 KECI      NBC         2017-06-08 Thu      0.0902              0.276 \n10 KPAX      CBS         2017-06-08 Thu      0.0668              0.305 \n# ℹ 2,550 more rows\n# ℹ 4 more variables: local_politics <dbl>, sinclair2017 <dbl>, post <dbl>,\n#   month <ord>\n```\n:::\n:::\n\n\n\n### Creating new variables \n\nYou can create new variables that are functions of old variables using the `mutate()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |> mutate(\n  national_local_diff = national_politics - local_politics) |>\n  select(callsign, date, national_politics, local_politics,\n         national_local_diff)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,560 × 5\n   callsign date       national_politics local_politics national_local_diff\n   <chr>    <date>                 <dbl>          <dbl>               <dbl>\n 1 KECI     2017-06-07            0.225          0.148               0.0761\n 2 KPAX     2017-06-07            0.283          0.123               0.160 \n 3 KRBC     2017-06-07            0.130          0.189              -0.0589\n 4 KTAB     2017-06-07            0.0901         0.138              -0.0476\n 5 KTMF     2017-06-07            0.152          0.129               0.0229\n 6 KTXS     2017-06-07            0.0925         0.0791              0.0134\n 7 KAEF     2017-06-08            0.213          0.228              -0.0151\n 8 KBVU     2017-06-08            0.169          0.247              -0.0781\n 9 KECI     2017-06-08            0.276          0.152               0.124 \n10 KPAX     2017-06-08            0.305          0.124               0.180 \n# ℹ 2,550 more rows\n```\n:::\n:::\n\n\n\n### Creating new variables based on yes/no conditions\n\nIf you want to create a new variable that can take on two values based on a logical conditional, you should use the `if_else()` function inside of `mutate()`. For instance, if we want to create a more nicely labeled version of the `sinclair2017` variable (which is 0/1), we could do:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  mutate(Ownership = if_else(sinclair2017 == 1,\n                             \"Acquired by Sinclair\",\n                             \"Not Acquired\")) |>\n  select(callsign, affiliation, date, sinclair2017, Ownership)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,560 × 5\n   callsign affiliation date       sinclair2017 Ownership           \n   <chr>    <chr>       <date>            <dbl> <chr>               \n 1 KECI     NBC         2017-06-07            1 Acquired by Sinclair\n 2 KPAX     CBS         2017-06-07            0 Not Acquired        \n 3 KRBC     NBC         2017-06-07            0 Not Acquired        \n 4 KTAB     CBS         2017-06-07            0 Not Acquired        \n 5 KTMF     ABC         2017-06-07            0 Not Acquired        \n 6 KTXS     ABC         2017-06-07            1 Acquired by Sinclair\n 7 KAEF     ABC         2017-06-08            1 Acquired by Sinclair\n 8 KBVU     FOX         2017-06-08            1 Acquired by Sinclair\n 9 KECI     NBC         2017-06-08            1 Acquired by Sinclair\n10 KPAX     CBS         2017-06-08            0 Not Acquired        \n# ℹ 2,550 more rows\n```\n:::\n:::\n\n\n\n### Summarizing a variable \n\nYou can calculate summaries of variables in the data set using the `summarize()` function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  summarize(\n    avg_ideology = mean(ideology),\n    sd_ideology = sd(ideology),\n    median_ideology = median(ideology)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n  avg_ideology sd_ideology median_ideology\n         <dbl>       <dbl>           <dbl>\n1       0.0907      0.0962          0.0929\n```\n:::\n:::\n\n\n\n\n### Summarizing variables by groups of rows\n\nBy default, `summarize()` calculates the summaries of variables for all rows in the data frame. You can also calculate these summaries within groups of rows defined by another variable in the data frame using the `group_by()` function before summarizing. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  group_by(month) |>\n  summarize(\n    avg_ideology = mean(ideology),\n    sd_ideology = sd(ideology),\n    median_ideology = median(ideology)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 4\n  month avg_ideology sd_ideology median_ideology\n  <ord>        <dbl>       <dbl>           <dbl>\n1 Jun         0.0786      0.0979          0.0838\n2 Jul         0.103       0.0888          0.0992\n3 Aug         0.105       0.0811          0.106 \n4 Sep         0.0751      0.0902          0.0768\n5 Oct         0.0862      0.110           0.0853\n6 Nov         0.0972      0.0893          0.102 \n7 Dec         0.0774      0.125           0.0878\n```\n:::\n:::\n\n\nHere, the `summarize()` function breaks apart the original data into smaller data frames for each month and applies the summary functions to those, then combines everything into one tibble. \n\n\n### Summarizing by multiple variables\n\nYou can group by multiple variables and `summarize()` will create groups based on every combination of each variable: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  group_by(sinclair2017, post) |>\n  summarize(\n    avg_ideology = mean(ideology)\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'sinclair2017'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n# Groups:   sinclair2017 [2]\n  sinclair2017  post avg_ideology\n         <dbl> <dbl>        <dbl>\n1            0     0       0.100 \n2            0     1       0.0768\n3            1     0       0.0936\n4            1     1       0.0938\n```\n:::\n:::\n\n\nYou'll notice the message that `summarize()` sends after using to let us know that resulting tibble is grouped by `sinclair2017`. By default, `summarize()` drops the last group you provided in `group_by` (`post` in this case).  This isn't an error message, it's just letting us know some helpful information. If you want to avoid this messaging displaying, you need to specify what grouping you want after using the `.groups` argument:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  group_by(sinclair2017, post) |>\n  summarize(\n    avg_ideology = mean(ideology),\n    .groups = \"drop_last\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n# Groups:   sinclair2017 [2]\n  sinclair2017  post avg_ideology\n         <dbl> <dbl>        <dbl>\n1            0     0       0.100 \n2            0     1       0.0768\n3            1     0       0.0936\n4            1     1       0.0938\n```\n:::\n:::\n\n\n\n### Summarizing across many variables\n\n\nIf you want to apply the same summary to multiple variables, you can use the `across(vars, fun)` function, where `vars` is a vector of variable names (specified like with `select()`) and `fun` is a summary function to apply to those variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  group_by(sinclair2017, post) |>\n  summarize(\n    across(c(ideology, national_politics), mean)\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'sinclair2017'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 4\n# Groups:   sinclair2017 [2]\n  sinclair2017  post ideology national_politics\n         <dbl> <dbl>    <dbl>             <dbl>\n1            0     0   0.100              0.134\n2            0     1   0.0768             0.126\n3            1     0   0.0936             0.137\n4            1     1   0.0938             0.155\n```\n:::\n:::\n\n\nAs with `select()`, you can use the `:` operator to select a range of variables \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  group_by(sinclair2017, post) |>\n  summarize(\n    across(ideology:local_politics, mean)\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'sinclair2017'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 5\n# Groups:   sinclair2017 [2]\n  sinclair2017  post ideology national_politics local_politics\n         <dbl> <dbl>    <dbl>             <dbl>          <dbl>\n1            0     0   0.100              0.134          0.168\n2            0     1   0.0768             0.126          0.167\n3            1     0   0.0936             0.137          0.157\n4            1     1   0.0938             0.155          0.139\n```\n:::\n:::\n\n\n\n### Table of counts of a categorical variable\n\nThere are two way to produce a table of counts of each category of a variable. The first is to use `group_by` and `summarize` along with the summary function `n()`, which returns the numbers of rows in each grouping (that is, each combination of the grouping variables):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  group_by(affiliation) |>\n  summarize(n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  affiliation     n\n  <chr>       <int>\n1 ABC           687\n2 CBS           758\n3 FOX           346\n4 NBC           769\n```\n:::\n:::\n\n\nA simpler way to acheive the same outcome is to use the `count()` function, which implements these two steps:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  count(affiliation)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  affiliation     n\n  <chr>       <int>\n1 ABC           687\n2 CBS           758\n3 FOX           346\n4 NBC           769\n```\n:::\n:::\n\n\n\n\n\n### Producing nicely formatted tables with `kable()`\n\nYou can take any tibble in R and convert it into a more readable output by passing it to `knitr::kable()`. In our homework, generally, we will save the tibble as an object and then pass it to this function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonth_summary <- news |>\n  group_by(month) |>\n  summarize(\n    avg_ideology = mean(ideology),\n    sd_ideology = sd(ideology)\n  )\n\nknitr::kable(month_summary)\n```\n\n::: {.cell-output-display}\n|month | avg_ideology| sd_ideology|\n|:-----|------------:|-----------:|\n|Jun   |    0.0785518|   0.0979339|\n|Jul   |    0.1032917|   0.0888328|\n|Aug   |    0.1049908|   0.0811141|\n|Sep   |    0.0751067|   0.0902003|\n|Oct   |    0.0861639|   0.1098108|\n|Nov   |    0.0971796|   0.0892845|\n|Dec   |    0.0773873|   0.1246451|\n:::\n:::\n\n\n\nYou can add informative column names to the table using the `col.names` argument. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::kable(\n  month_summary,\n  col.names = c(\"Month\", \"Average Ideology\", \"SD of Ideology\")\n)\n```\n\n::: {.cell-output-display}\n|Month | Average Ideology| SD of Ideology|\n|:-----|----------------:|--------------:|\n|Jun   |        0.0785518|      0.0979339|\n|Jul   |        0.1032917|      0.0888328|\n|Aug   |        0.1049908|      0.0811141|\n|Sep   |        0.0751067|      0.0902003|\n|Oct   |        0.0861639|      0.1098108|\n|Nov   |        0.0971796|      0.0892845|\n|Dec   |        0.0773873|      0.1246451|\n:::\n:::\n\n\nFinally, we can round the numbers in the table to be a bit nicer using the `digits` argument. This will tell `kable()` how many significant digiits to show. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::kable(\n  month_summary,\n  col.names = c(\"Month\", \"Average Ideology\", \"SD of Ideology\"),\n  digits = 3\n)\n```\n\n::: {.cell-output-display}\n|Month | Average Ideology| SD of Ideology|\n|:-----|----------------:|--------------:|\n|Jun   |            0.079|          0.098|\n|Jul   |            0.103|          0.089|\n|Aug   |            0.105|          0.081|\n|Sep   |            0.075|          0.090|\n|Oct   |            0.086|          0.110|\n|Nov   |            0.097|          0.089|\n|Dec   |            0.077|          0.125|\n:::\n:::\n\n\n\n### Barplots of counts\n\nYou can visualize counts of a variable using a barplot:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  ggplot(mapping = aes(x = affiliation)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](cheatsheet_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\n\n\n### Barplots of other summaries \n\nWe can use barplots to visualize  other grouped summaries like means, but we need to use the `geom_col()` geom instead and specify the variable you want to be the height of the bars .\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  group_by(affiliation) |>\n  summarize(\n    avg_ideology = mean(ideology)\n  ) |>\n  ggplot(mapping = aes(x = affiliation, y = avg_ideology)) +\n  geom_col()\n```\n\n::: {.cell-output-display}\n![](cheatsheet_files/figure-html/unnamed-chunk-45-1.png){width=672}\n:::\n:::\n\n\n\n### Reordering/sorting barplot axes \n\nOften we want to sort the barplot axes to be in the order of the variable of interest so we can quickly compare them. We can use the `fct_reorder(group_var, ordering_var)` function to do this where the `group_var` is the grouping variable that is going on the axes and the `ordering_var` is the variable that we will sort the groups on. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  group_by(affiliation) |>\n  summarize(\n    avg_ideology = mean(ideology)\n  ) |>\n  ggplot(mapping = aes(x = fct_reorder(affiliation, avg_ideology),\n                       y = avg_ideology)) +\n  geom_col()\n```\n\n::: {.cell-output-display}\n![](cheatsheet_files/figure-html/unnamed-chunk-46-1.png){width=672}\n:::\n:::\n\n\n\n### Coloring barplots by another variable \n\nYou can color the barplots by a another variable using the `fill` aesthetic:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  group_by(callsign, affiliation) |>\n  summarize(\n    avg_ideology = mean(ideology)\n  ) |>\n  slice_max(avg_ideology, n = 10) |>\n  ggplot(mapping = aes(y = fct_reorder(callsign, avg_ideology),\n                       x = avg_ideology)) +\n  geom_col(mapping = aes(fill = affiliation))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'callsign'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output-display}\n![](cheatsheet_files/figure-html/unnamed-chunk-47-1.png){width=672}\n:::\n:::\n\n\n\n### Creating logical vectors\n\nYou can create logical variables in your tibbles using mutate:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  mutate(\n    right_leaning = ideology > 0,\n    fall = month == \"Sep\" | month == \"Oct\" | month == \"Nov\",\n    .keep = \"used\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,560 × 4\n    ideology month right_leaning fall \n       <dbl> <ord> <lgl>         <lgl>\n 1  0.0655   Jun   TRUE          FALSE\n 2  0.0853   Jun   TRUE          FALSE\n 3  0.0183   Jun   TRUE          FALSE\n 4  0.0850   Jun   TRUE          FALSE\n 5  0.0842   Jun   TRUE          FALSE\n 6 -0.000488 Jun   FALSE         FALSE\n 7  0.0426   Jun   TRUE          FALSE\n 8 -0.0860   Jun   FALSE         FALSE\n 9  0.0902   Jun   TRUE          FALSE\n10  0.0668   Jun   TRUE          FALSE\n# ℹ 2,550 more rows\n```\n:::\n:::\n\n\n\nThe `.keep = \"used\"` argument here tells mutate to only return the variables created and any variables used to create them. We're using it here for display purposes. \n\nYou can filter based on these logical variables. In particular, if we want to subset to rows where both `right_leaning` and `fall` were `TRUE` we could do the following filter:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  mutate(\n    right_leaning = ideology > 0,\n    fall = month == \"Sep\" | month == \"Oct\" | month == \"Nov\",\n    .keep = \"used\"\n  ) |>\n  filter(right_leaning & fall)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,050 × 4\n   ideology month right_leaning fall \n      <dbl> <ord> <lgl>         <lgl>\n 1   0.121  Sep   TRUE          TRUE \n 2   0.0564 Sep   TRUE          TRUE \n 3   0.0564 Sep   TRUE          TRUE \n 4   0.324  Sep   TRUE          TRUE \n 5   0.0649 Sep   TRUE          TRUE \n 6   0.0613 Sep   TRUE          TRUE \n 7   0.187  Sep   TRUE          TRUE \n 8   0.0297 Sep   TRUE          TRUE \n 9   0.151  Sep   TRUE          TRUE \n10   0.186  Sep   TRUE          TRUE \n# ℹ 1,040 more rows\n```\n:::\n:::\n\n\n### Using `!` to negate logicals\n\nAny time you place the exclamation point in front of a logical, it will turn any `TRUE` into a `FALSE` and vice versa. For instance, if we wanted left leaning days in the fall, we could used\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  mutate(\n    right_leaning = ideology > 0,\n    fall = month == \"Sep\" | month == \"Oct\" | month == \"Nov\",\n    .keep = \"used\"\n  ) |>\n  filter(!right_leaning & fall)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 167 × 4\n   ideology month right_leaning fall \n      <dbl> <ord> <lgl>         <lgl>\n 1 -0.0387  Sep   FALSE         TRUE \n 2 -0.302   Sep   FALSE         TRUE \n 3 -0.00694 Sep   FALSE         TRUE \n 4 -0.0140  Sep   FALSE         TRUE \n 5 -0.0294  Sep   FALSE         TRUE \n 6 -0.0113  Sep   FALSE         TRUE \n 7 -0.105   Sep   FALSE         TRUE \n 8 -0.0286  Sep   FALSE         TRUE \n 9 -0.0462  Sep   FALSE         TRUE \n10 -0.0313  Sep   FALSE         TRUE \n# ℹ 157 more rows\n```\n:::\n:::\n\n\nOr if we wanted to subset to any combination **except** right leaning and fall, we could negate the AND statement using parentheses:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  mutate(\n    right_leaning = ideology > 0,\n    fall = month == \"Sep\" | month == \"Oct\" | month == \"Nov\",\n    .keep = \"used\"\n  ) |>\n  filter(!(right_leaning & fall))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,510 × 4\n    ideology month right_leaning fall \n       <dbl> <ord> <lgl>         <lgl>\n 1  0.0655   Jun   TRUE          FALSE\n 2  0.0853   Jun   TRUE          FALSE\n 3  0.0183   Jun   TRUE          FALSE\n 4  0.0850   Jun   TRUE          FALSE\n 5  0.0842   Jun   TRUE          FALSE\n 6 -0.000488 Jun   FALSE         FALSE\n 7  0.0426   Jun   TRUE          FALSE\n 8 -0.0860   Jun   FALSE         FALSE\n 9  0.0902   Jun   TRUE          FALSE\n10  0.0668   Jun   TRUE          FALSE\n# ℹ 1,500 more rows\n```\n:::\n:::\n\n\nThis is often used in combination with `%in%` to acheive a \"not in\" logical:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  filter(!(affiliation %in% c(\"FOX\", \"ABC\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,527 × 10\n   callsign affiliation date       weekday ideology national_politics\n   <chr>    <chr>       <date>     <ord>      <dbl>             <dbl>\n 1 KECI     NBC         2017-06-07 Wed       0.0655            0.225 \n 2 KPAX     CBS         2017-06-07 Wed       0.0853            0.283 \n 3 KRBC     NBC         2017-06-07 Wed       0.0183            0.130 \n 4 KTAB     CBS         2017-06-07 Wed       0.0850            0.0901\n 5 KECI     NBC         2017-06-08 Thu       0.0902            0.276 \n 6 KPAX     CBS         2017-06-08 Thu       0.0668            0.305 \n 7 KRBC     NBC         2017-06-08 Thu       0.108             0.156 \n 8 KTAB     CBS         2017-06-08 Thu      -0.0178            0.0726\n 9 KECI     NBC         2017-06-09 Fri       0.115             0.216 \n10 KPAX     CBS         2017-06-09 Fri       0.0882            0.315 \n# ℹ 1,517 more rows\n# ℹ 4 more variables: local_politics <dbl>, sinclair2017 <dbl>, post <dbl>,\n#   month <ord>\n```\n:::\n:::\n\n\n\n### Grouped summaries with `any()` and `all()` \n\nOnce you group a tibble, you can summarize logicals within groups using two commands. `any()` will return `TRUE` if a logical is `TRUE` for any row in a group and `FALSE` otherwise. `all()` will return `TRUE` when the logical inside it is `TRUE` for all rows in a group and `FALSE` otherwise. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  group_by(callsign) |>\n  summarize(\n    any_liberal = any(ideology < 0),\n    all_local = all(national_politics < local_politics)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 22 × 3\n   callsign any_liberal all_local\n   <chr>    <lgl>       <lgl>    \n 1 KAEF     TRUE        FALSE    \n 2 KBVU     TRUE        FALSE    \n 3 KBZK     TRUE        FALSE    \n 4 KCVU     TRUE        FALSE    \n 5 KECI     TRUE        FALSE    \n 6 KHSL     TRUE        FALSE    \n 7 KNVN     TRUE        FALSE    \n 8 KPAX     TRUE        FALSE    \n 9 KRBC     TRUE        FALSE    \n10 KRCR     TRUE        FALSE    \n# ℹ 12 more rows\n```\n:::\n:::\n\n\n\n### Converting logicals\n\n\nWhen passed to `sum()` or `mean()`, `TRUE` is converted to 1 and `FALSE` is converted to 0. This means that `sum()` will return the number of `TRUE` values in a vector and `mean()` will return the proportion of `TRUE` values. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(c(TRUE, FALSE, TRUE, FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nmean(c(TRUE, FALSE, TRUE, FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5\n```\n:::\n:::\n\n\n### Grouped logical summaries with sums and means\n\nAfter grouping, you can summarize using either the `sum()` or `mean()` function on a logical. In this case, the `sum()` will give you the number of time the statement is `TRUE` within a group, and `mean()` will give you the proportion of rows that are `TRUE` within a group. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  group_by(callsign) |>\n  summarize(\n    prop_liberal = mean(ideology < 0),\n    num_local_bigger = sum(national_politics < local_politics)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 22 × 3\n   callsign prop_liberal num_local_bigger\n   <chr>           <dbl>            <int>\n 1 KAEF           0.138               111\n 2 KBVU           0.143                31\n 3 KBZK           0.0526               11\n 4 KCVU           0.185                38\n 5 KECI           0.137                44\n 6 KHSL           0.132               127\n 7 KNVN           0.115               130\n 8 KPAX           0.0833               74\n 9 KRBC           0.196               103\n10 KRCR           0.0992               99\n# ℹ 12 more rows\n```\n:::\n:::\n\n\n\n## Causality (Week 4)\n\nFor this week, we'll use the data from the transphobia randomized experiment \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrans\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 565 × 9\n     age female voted_gen_14 voted_gen_12 treat_ind racename         democrat\n   <dbl>  <dbl>        <dbl>        <dbl>     <dbl> <chr>               <dbl>\n 1    29      0            0            1         0 African American        1\n 2    59      1            1            0         1 African American        1\n 3    35      1            1            1         1 African American        1\n 4    63      1            1            1         1 African American        1\n 5    65      0            1            1         1 African American        0\n 6    51      1            1            1         0 Caucasian               0\n 7    26      1            1            1         0 African American        1\n 8    62      1            1            1         1 African American        1\n 9    37      0            1            1         0 Caucasian               0\n10    51      1            1            1         0 Caucasian               0\n# ℹ 555 more rows\n# ℹ 2 more variables: nondiscrim_pre <dbl>, nondiscrim_post <dbl>\n```\n:::\n:::\n\n\n### Calculating a difference in means by filtering\n\nYou can calculate a difference in means by creating separate summaries of the treatment and control arms of an experiment or observational study and then taking the differences between them:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntreat_mean <- trans |>\n  filter(treat_ind == 1) |>\n  summarize(nondiscrim_mean = mean(nondiscrim_post))\ntreat_mean\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  nondiscrim_mean\n            <dbl>\n1           0.687\n```\n:::\n\n```{.r .cell-code}\ncontrol_mean <- trans |>\n  filter(treat_ind == 0) |>\n  summarize(nondiscrim_mean = mean(nondiscrim_post))\ncontrol_mean\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  nondiscrim_mean\n            <dbl>\n1           0.648\n```\n:::\n\n```{.r .cell-code}\ndiff_in_means <- treat_mean - control_mean\ndiff_in_means\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  nondiscrim_mean\n1      0.03896674\n```\n:::\n:::\n\n\n\n### Pivoting a tibble to make a cross-tab\n\nWhen grouping by two variables, we sometimes would like the values of one variable to be in the rows and values of the other variable to be in the columns. But `group_by()` and `summarize()` by default puts each combination of values for the two variables into rows. We can use the `pivot_wider` function to move one of the variables (specified with the `names_from` argument) to the columns. The `values_from` argument tells R what variable should it use to fil in the data in the resulting table. \n\nSo if we wanted to get counts of race (rows) by treatment group (columns), we could start with getting the counts:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrans |>\n  group_by(treat_ind, racename) |>\n  summarize(n = n())\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'treat_ind'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 3\n# Groups:   treat_ind [2]\n  treat_ind racename             n\n      <dbl> <chr>            <int>\n1         0 African American    58\n2         0 Asian                2\n3         0 Caucasian           77\n4         0 Hispanic           150\n5         1 African American    68\n6         1 Asian                4\n7         1 Caucasian           75\n8         1 Hispanic           130\n9         1 Native American      1\n```\n:::\n:::\n\n\nThen we can pivot the treatment group to the columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrans |>\n  group_by(treat_ind, racename) |>\n  summarize(n = n()) |>\n  pivot_wider(\n    names_from = treat_ind,\n    values_from = n\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'treat_ind'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n  racename           `0`   `1`\n  <chr>            <int> <int>\n1 African American    58    68\n2 Asian                2     4\n3 Caucasian           77    75\n4 Hispanic           150   130\n5 Native American     NA     1\n```\n:::\n:::\n\n\n\n### Calculating difference in means by pivoting\n\nNow that we know pivoting, we can use this to calculate difference in means instead of the filter approach. We first calculate the means by treatment group, pivot the rows to columns, and finally use `mutate()` to create the difference between the means.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrans |>\n  group_by(treat_ind) |>\n  summarize(nondiscrim_mean = mean(nondiscrim_post)) |>\n  pivot_wider(\n    names_from = treat_ind,\n    values_from = nondiscrim_mean\n  ) |>\n  mutate(\n    diff_in_means = `1` - `0`\n  ) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n    `0`   `1` diff_in_means\n  <dbl> <dbl>         <dbl>\n1 0.648 0.687        0.0390\n```\n:::\n:::\n\n\n\n### Creating new labels for variables to make nicer tables\n\nAbove we had to use the backticks to refer to the 1/0 variable names when calculating the differences in means. We can create slightly nicer output by relabeling the `treat_ind` variable using `if_else`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrans |>\n  mutate(\n    treat_ind = if_else(treat_ind == 1, \"Treated\", \"Control\")\n  ) |>  \n  group_by(treat_ind) |>\n  summarize(nondiscrim_mean = mean(nondiscrim_post)) |>\n  pivot_wider(\n    names_from = treat_ind,\n    values_from = nondiscrim_mean\n  ) |>\n  mutate(\n    diff_in_means = Treated - Control\n  ) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n  Control Treated diff_in_means\n    <dbl>   <dbl>         <dbl>\n1   0.648   0.687        0.0390\n```\n:::\n:::\n\n\n\n### Calculating difference in means by two-level grouping variable\n\nIf we have a two-level grouping variable like `democrat`, we can create nice labels for that variable and just add it to the `group_by` call to get the difference in means within levels of this variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrans |>\n  mutate(\n    treat_ind = if_else(treat_ind == 1, \"Treated\", \"Control\"),\n    party = if_else(democrat == 1, \"Democrat\", \"Non-Democrat\")\n  ) |>\n  group_by(treat_ind, party) |>\n  summarize(nondiscrim_mean = mean(nondiscrim_post)) |>\n  pivot_wider(\n    names_from = treat_ind,\n    values_from = nondiscrim_mean\n  ) |>  \n  mutate(\n    diff_in_means = Treated - Control\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'treat_ind'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 4\n  party        Control Treated diff_in_means\n  <chr>          <dbl>   <dbl>         <dbl>\n1 Democrat       0.704   0.754        0.0498\n2 Non-Democrat   0.605   0.628        0.0234\n```\n:::\n:::\n\n\n\n### Creating grouping variables with more than 2 levels\n\nYou can use [`case_when()`](https://dplyr.tidyverse.org/reference/case_when.html) to create a variable that can take on more than 2 values based on conditions of a variable in the tibble:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrans |>\n  mutate(\n    age_group = case_when(\n      age < 25 ~ \"Under 25\",\n      age >=25 & age < 65 ~ \"Bewteen 25 and 65\",\n      age >= 65 ~ \"Older than 65\"\n    )\n  ) |>\n  select(age, age_group)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 565 × 2\n     age age_group        \n   <dbl> <chr>            \n 1    29 Bewteen 25 and 65\n 2    59 Bewteen 25 and 65\n 3    35 Bewteen 25 and 65\n 4    63 Bewteen 25 and 65\n 5    65 Older than 65    \n 6    51 Bewteen 25 and 65\n 7    26 Bewteen 25 and 65\n 8    62 Bewteen 25 and 65\n 9    37 Bewteen 25 and 65\n10    51 Bewteen 25 and 65\n# ℹ 555 more rows\n```\n:::\n:::\n\n\n\n### Calculating difference in mean by grouping variable with more than 2 levels\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrans |>\n  mutate(\n    treat_ind = if_else(treat_ind == 1, \"Treated\", \"Control\"),\n    age_group = case_when(\n      age < 25 ~ \"Under 25\",\n      age >=25 & age < 65 ~ \"Bewteen 25 and 65\",\n      age >= 65 ~ \"Older than 65\"\n    )\n  ) |>\n  group_by(treat_ind, age_group) |>\n  summarize(nondiscrim_mean = mean(nondiscrim_post)) |>\n  pivot_wider(\n    names_from = treat_ind,\n    values_from = nondiscrim_mean\n  ) |>  \n  mutate(\n    diff_in_means = Treated - Control\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'treat_ind'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 4\n  age_group         Control Treated diff_in_means\n  <chr>               <dbl>   <dbl>         <dbl>\n1 Bewteen 25 and 65   0.694   0.683       -0.0112\n2 Older than 65       0.576   0.614        0.0378\n3 Under 25            0.556   0.829        0.273 \n```\n:::\n:::\n\n\n\n### Calculating before and after difference in means\n\n\nWhen we're estimating causal effects using a before and after design, we can usually create a variable that is the change in the outcome over time for each row and then take the mean of that. For example, in the newspapers data we have the vote for Labour outcome before the treatment (1992) and after (1997):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnewspapers |>\n  filter(to_labour == 1) |>  \n  mutate(\n    vote_change = vote_lab_97 - vote_lab_92\n  ) |>  \n  summarize(avg_change = mean(vote_change))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  avg_change\n       <dbl>\n1      0.190\n```\n:::\n:::\n\n\n\n### Calculating difference-in-differences estimator\n\nWhen you want to use the difference in differences estimator, you simply need to take the difference between the average changes over time in the treatment group (`to_labour == 1`) and the control group (`to_labour == 0`). We can do this by adding a `group_by` step:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnewspapers |>\n  mutate(\n    vote_change = vote_lab_97 - vote_lab_92,\n    to_labour = if_else(to_labour == 1, \"switched\", \"unswitched\")\n  ) |>\n  group_by(to_labour) |>  \n  summarize(avg_change = mean(vote_change)) |>\n  pivot_wider(\n    names_from = to_labour,\n    values_from = avg_change\n  ) |>\n  mutate(DID = switched - unswitched)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n  switched unswitched    DID\n     <dbl>      <dbl>  <dbl>\n1    0.190      0.110 0.0796\n```\n:::\n:::\n\n\n\n## Summarizing data (Week 5)\n\n\n### Calculating the mean, median, and standard deviation\n\nMany of the summary functions have intuitive names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  summarize(\n    gdp_mean = mean(gdpPercap),\n    gdp_median = median(gdpPercap),\n    gdp_sd = sd(gdpPercap)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n  gdp_mean gdp_median gdp_sd\n     <dbl>      <dbl>  <dbl>\n1    7215.      3532.  9857.\n```\n:::\n:::\n\n\n\nYou can also use these functions outside of a `summarize()` call by accessing variables with the `$` operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(gapminder$gdpPercap)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7215.327\n```\n:::\n:::\n\n\n\n### Adding a vertical line to a plot\n\nYou can layer on vertical lines to a ggplot using the [`geom_vline()`](https://ggplot2.tidyverse.org/reference/geom_abline.html) function. For horizontal lines, use `geom_hline()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(gapminder, aes(x = lifeExp)) +\n  geom_histogram(binwidth = 1) +\n  geom_vline(aes(xintercept = mean(lifeExp)), color = \"indianred\") +\n  geom_vline(aes(xintercept = median(lifeExp)), color = \"dodgerblue\")\n```\n\n::: {.cell-output-display}\n![](cheatsheet_files/figure-html/unnamed-chunk-69-1.png){width=672}\n:::\n:::\n\n\n\n### Dropping missing rows with missing data\n\nTo drop any row of a data frame with missing values in any variable, you can use the `drop_na()` function. Here we use the `nrow()` function to show how many rows each tibble has.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncces_2020 |>\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 51551\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncces_2020 |>\n  drop_na() |>\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 45651\n```\n:::\n:::\n\n\nBy default `drop_na()` drops rows that have any missingness. If you want to drop rows based on being missing only for a particular variable, just pass the variable name to the function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncces_2020 |>\n  drop_na(turnout_self) |>\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 48462\n```\n:::\n:::\n\n\n\n### Removing missing values in summary functions\n\nMost summary functions have an argument `na.rm` (for \"NA remove\") that is `FALSE` by default, meaning it tries to calculate summaries with missing values included:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncces_2020 |>\n  summarize(avg_turnout = mean(turnout_self))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  avg_turnout\n        <dbl>\n1          NA\n```\n:::\n:::\n\n\nTo remove missing values and calculate the summary based on the observed values for that variable, set `na.rm = TRUE`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncces_2020 |>\n  summarize(avg_turnout = mean(turnout_self, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  avg_turnout\n        <dbl>\n1       0.942\n```\n:::\n:::\n\n\n\n### Detecting missing values \n\nYou cannot use `x == NA` for detecting missing values in R because it treats missing values quite literally and just returns `NA` for all values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(5, 6, NA, 0) == NA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA NA NA\n```\n:::\n:::\n\n\n\nInstead you can use `is.na()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(c(5, 6, NA, 0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE FALSE\n```\n:::\n:::\n\n\n\nYou can negate this to test for non-missing values:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n!is.na(c(5, 6, NA, 0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE  TRUE\n```\n:::\n:::\n\n\n\n### Using `is.na` to summarize missingness\n\n\nApplying `mean()` to  `is.na()` output will tell us the proportion of values in a vector that are missing. We can combine this with `group_by` and `summarize` to see what share of each party ID response are missing turnout:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncces_2020 |>\n  group_by(pid3) |>\n  summarize(\n    missing_turnout = mean(is.na(turnout_self))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 2\n  pid3        missing_turnout\n  <fct>                 <dbl>\n1 Democrat             0.0280\n2 Republican           0.0403\n3 Independent          0.0718\n4 Other                0.0709\n5 Not sure             0.431 \n```\n:::\n:::\n\n\n\n### Proportion table for one variable\n\nTo get a proportion table for a single categorical variable, start with the approach to creating a table of counts of each category. Then just add a `mutate()` step to get the proportion:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncces_2020 |>\n  group_by(pres_vote) |>\n  summarize(n = n()) |>\n  mutate(\n    prop = n / sum(n)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 3\n  pres_vote                        n     prop\n  <fct>                        <int>    <dbl>\n1 Joe Biden (Democrat)         26188 0.508   \n2 Donald J. Trump (Republican) 17702 0.343   \n3 Other                         1458 0.0283  \n4 I did not vote in this race    100 0.00194 \n5 I did not vote                  13 0.000252\n6 Not sure                       190 0.00369 \n7 <NA>                          5900 0.114   \n```\n:::\n:::\n\n\n\n### Proportion table with two variables\n\nWith two variables, we take the same approach as for one variable, but we need to be careful about the grouping:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncces_2020 |>\n  filter(pres_vote %in% c(\"Joe Biden (Democrat)\",\n                          \"Donald J. Trump (Republican)\")) |>  \n  group_by(pid3, pres_vote) |>\n  summarize(n = n()) |>\n  mutate(prop = n / sum(n))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'pid3'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 4\n# Groups:   pid3 [5]\n   pid3        pres_vote                        n   prop\n   <fct>       <fct>                        <int>  <dbl>\n 1 Democrat    Joe Biden (Democrat)         17649 0.968 \n 2 Democrat    Donald J. Trump (Republican)   581 0.0319\n 3 Republican  Joe Biden (Democrat)           856 0.0712\n 4 Republican  Donald J. Trump (Republican) 11164 0.929 \n 5 Independent Joe Biden (Democrat)          6601 0.571 \n 6 Independent Donald J. Trump (Republican)  4951 0.429 \n 7 Other       Joe Biden (Democrat)           735 0.487 \n 8 Other       Donald J. Trump (Republican)   774 0.513 \n 9 Not sure    Joe Biden (Democrat)           347 0.599 \n10 Not sure    Donald J. Trump (Republican)   232 0.401 \n```\n:::\n:::\n\n\nAfter summarizing, the tibble drops the last grouping variable and groups the resulting tibble by the remaining variable(s). In this case, `pres_vote` is dropped and the tibble is now grouped by `pid3`. This means that when we call `mutate()`, the calculations will be done **within** levels of `pid3`. So the first row here is telling us the the share of Democrats that voted for Biden is 0.968. \n\n\nIf we want to have the proportion be as a share of the `pres_vote` instead, we can reorder the grouping variables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncces_2020 |>\n  filter(pres_vote %in% c(\"Joe Biden (Democrat)\",\n                          \"Donald J. Trump (Republican)\")) |>  \n  group_by(pres_vote, pid3) |>\n  summarize(n = n()) |>\n  mutate(prop = n / sum(n))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'pres_vote'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 4\n# Groups:   pres_vote [2]\n   pres_vote                    pid3            n   prop\n   <fct>                        <fct>       <int>  <dbl>\n 1 Joe Biden (Democrat)         Democrat    17649 0.674 \n 2 Joe Biden (Democrat)         Republican    856 0.0327\n 3 Joe Biden (Democrat)         Independent  6601 0.252 \n 4 Joe Biden (Democrat)         Other         735 0.0281\n 5 Joe Biden (Democrat)         Not sure      347 0.0133\n 6 Donald J. Trump (Republican) Democrat      581 0.0328\n 7 Donald J. Trump (Republican) Republican  11164 0.631 \n 8 Donald J. Trump (Republican) Independent  4951 0.280 \n 9 Donald J. Trump (Republican) Other         774 0.0437\n10 Donald J. Trump (Republican) Not sure      232 0.0131\n```\n:::\n:::\n\n\n\nFinally, if we want the proportions to be out of all rows of the data, we can tell `summarize()` to drop the grouping:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncces_2020 |>\n  filter(pres_vote %in% c(\"Joe Biden (Democrat)\",\n                          \"Donald J. Trump (Republican)\")) |>  \n  group_by(pid3, pres_vote) |>\n  summarize(n = n(), .groups = \"drop\") |>\n  mutate(prop = n / sum(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 4\n   pid3        pres_vote                        n    prop\n   <fct>       <fct>                        <int>   <dbl>\n 1 Democrat    Joe Biden (Democrat)         17649 0.402  \n 2 Democrat    Donald J. Trump (Republican)   581 0.0132 \n 3 Republican  Joe Biden (Democrat)           856 0.0195 \n 4 Republican  Donald J. Trump (Republican) 11164 0.254  \n 5 Independent Joe Biden (Democrat)          6601 0.150  \n 6 Independent Donald J. Trump (Republican)  4951 0.113  \n 7 Other       Joe Biden (Democrat)           735 0.0167 \n 8 Other       Donald J. Trump (Republican)   774 0.0176 \n 9 Not sure    Joe Biden (Democrat)           347 0.00791\n10 Not sure    Donald J. Trump (Republican)   232 0.00529\n```\n:::\n:::\n\n\n\n### Create cross-tab proportion tables\n\nWe can pivot our proportion tables to create cross-tabs, but if we leave in the count variable, we get output that we don't expect:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncces_2020 |>\n  filter(pres_vote %in% c(\"Joe Biden (Democrat)\",\n                          \"Donald J. Trump (Republican)\")) |>  \n  group_by(pid3, pres_vote) |>\n  summarize(n = n()) |>\n  mutate(prop = n / sum(n)) |>\n  pivot_wider(\n    names_from = pres_vote,\n    values_from = prop\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'pid3'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 4\n# Groups:   pid3 [5]\n   pid3            n `Joe Biden (Democrat)` `Donald J. Trump (Republican)`\n   <fct>       <int>                  <dbl>                          <dbl>\n 1 Democrat    17649                 0.968                         NA     \n 2 Democrat      581                NA                              0.0319\n 3 Republican    856                 0.0712                        NA     \n 4 Republican  11164                NA                              0.929 \n 5 Independent  6601                 0.571                         NA     \n 6 Independent  4951                NA                              0.429 \n 7 Other         735                 0.487                         NA     \n 8 Other         774                NA                              0.513 \n 9 Not sure      347                 0.599                         NA     \n10 Not sure      232                NA                              0.401 \n```\n:::\n:::\n\n\n\nTo combat this, we can either drop the count variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncces_2020 |>\n  filter(pres_vote %in% c(\"Joe Biden (Democrat)\",\n                          \"Donald J. Trump (Republican)\")) |>  \n  group_by(pid3, pres_vote) |>\n  summarize(n = n()) |>\n  mutate(prop = n / sum(n)) |>\n  select(-n) |>  \n  pivot_wider(\n    names_from = pres_vote,\n    values_from = prop\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'pid3'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n# Groups:   pid3 [5]\n  pid3        `Joe Biden (Democrat)` `Donald J. Trump (Republican)`\n  <fct>                        <dbl>                          <dbl>\n1 Democrat                    0.968                          0.0319\n2 Republican                  0.0712                         0.929 \n3 Independent                 0.571                          0.429 \n4 Other                       0.487                          0.513 \n5 Not sure                    0.599                          0.401 \n```\n:::\n:::\n\n\n\nOr we can also be specific about what variables we want on the rows. We can use the `id_cols` argument to specify just the variables that will go on the rows:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncces_2020 |>\n  filter(pres_vote %in% c(\"Joe Biden (Democrat)\",\n                          \"Donald J. Trump (Republican)\")) |>  \n  group_by(pid3, pres_vote) |>\n  summarize(n = n()) |>\n  mutate(prop = n / sum(n)) |>\n  pivot_wider(\n    id_cols = pid3,\n    names_from = pres_vote,\n    values_from = prop\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'pid3'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n# Groups:   pid3 [5]\n  pid3        `Joe Biden (Democrat)` `Donald J. Trump (Republican)`\n  <fct>                        <dbl>                          <dbl>\n1 Democrat                    0.968                          0.0319\n2 Republican                  0.0712                         0.929 \n3 Independent                 0.571                          0.429 \n4 Other                       0.487                          0.513 \n5 Not sure                    0.599                          0.401 \n```\n:::\n:::\n\n\n\n### Visualizing a proportion table\n\nWe can visualize our proportion table using by mapping the grouping variable to the `x` axis and the non-grouped variable to the `fill` aesthetic. We also need to use the `position = \"dodge\"` argument to the `geom_col()` function so that the two columns in each group don't overlap.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncces_2020 |>\n  filter(pres_vote %in% c(\"Joe Biden (Democrat)\",\n                          \"Donald J. Trump (Republican)\")) |>\n  mutate(pres_vote = if_else(pres_vote == \"Joe Biden (Democrat)\",\n                             \"Biden\", \"Trump\")) |>  \n  group_by(pid3, pres_vote) |>\n  summarize(n = n()) |>\n  mutate(prop = n / sum(n)) |>\n  \nggplot(aes(x = pid3, y = prop, fill = pres_vote)) +\n  geom_col(position = \"dodge\") +\n  scale_fill_manual(values = c(Biden = \"steelblue1\", Trump = \"indianred1\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'pid3'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output-display}\n![](cheatsheet_files/figure-html/crosstab-plot-1.png){width=672}\n:::\n:::\n\n\n## Bivariate Relationships and Joins (Week 6)\n\n### Calculating a correlation\n\nYou can calcuate a correlation between two variables using the `cor` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncor(news$national_politics, news$local_politics)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.05994132\n```\n:::\n:::\n\n\nYou can also use the pipe and summarize:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnews |>\n  summarize(cor(national_politics, local_politics))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  `cor(national_politics, local_politics)`\n                                     <dbl>\n1                                  -0.0599\n```\n:::\n:::\n\n\nWhen there are missing values in one of the variables, the correlation will be `NA`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncor(covid_votes$one_dose_5plus_pct, covid_votes$dem_pct_2020)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nIn that case, you can use the argument `use = \"pairwise\"` to remove the observations with missing values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncor(covid_votes$one_dose_5plus_pct, covid_votes$dem_pct_2020,\n    use = \"pairwise\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.6664387\n```\n:::\n:::\n\n\n\n### Writing a function\n\nYou can create a function with the `function()` function (oof). The arguments in the `function()` call will become the arguments of your function. For example, if we want to create a z-score function that takes in a vector and coverts it to a z-score, we can create a function for this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz_score <- function(x) {\n  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)\n}\n```\n:::\n\n\nHere, `x` is the argument that takes in the vector and it is used inside the function body to perform the task. Let's call the function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz_score(x = c(1, 2, 3, 4, 5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1.2649111 -0.6324555  0.0000000  0.6324555  1.2649111\n```\n:::\n:::\n\n\nWhat happens here is that R runs the code inside the function definition, replacing `x` with the vector we pass to `x`, which in this case is `c(1, 2, 3, 4, 5)`. \n\n\n### Pivoting longer\n\n\nWe sometimes have data that has data in the column names that we would actually like to be in the data frame itself. When this happens, we need the opposite of `pivot_wider` which is called `pivot_longer`. For example, the `mortality` data has the years in the column names, but we want the rows to be country-years:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmortality\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 217 × 52\n   country      country_code indicator `1972` `1973` `1974` `1975` `1976` `1977`\n   <chr>        <chr>        <chr>      <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>\n 1 Aruba        ABW          Mortalit…   NA     NA     NA     NA     NA     NA  \n 2 Afghanistan  AFG          Mortalit…  291    285.   280.   274.   268    262. \n 3 Angola       AGO          Mortalit…   NA     NA     NA     NA     NA     NA  \n 4 Albania      ALB          Mortalit…   NA     NA     NA     NA     NA     NA  \n 5 Andorra      AND          Mortalit…   NA     NA     NA     NA     NA     NA  \n 6 United Arab… ARE          Mortalit…   80.1   72.6   65.7   59.4   53.6   48.3\n 7 Argentina    ARG          Mortalit…   69.7   68.2   66.1   63.3   59.8   55.7\n 8 Armenia      ARM          Mortalit…   NA     NA     NA     NA     87.1   83.6\n 9 American Sa… ASM          Mortalit…   NA     NA     NA     NA     NA     NA  \n10 Antigua and… ATG          Mortalit…   26.9   25.1   23.5   22.1   20.8   19.5\n# ℹ 207 more rows\n# ℹ 43 more variables: `1978` <dbl>, `1979` <dbl>, `1980` <dbl>, `1981` <dbl>,\n#   `1982` <dbl>, `1983` <dbl>, `1984` <dbl>, `1985` <dbl>, `1986` <dbl>,\n#   `1987` <dbl>, `1988` <dbl>, `1989` <dbl>, `1990` <dbl>, `1991` <dbl>,\n#   `1992` <dbl>, `1993` <dbl>, `1994` <dbl>, `1995` <dbl>, `1996` <dbl>,\n#   `1997` <dbl>, `1998` <dbl>, `1999` <dbl>, `2000` <dbl>, `2001` <dbl>,\n#   `2002` <dbl>, `2003` <dbl>, `2004` <dbl>, `2005` <dbl>, `2006` <dbl>, …\n```\n:::\n:::\n\n\nWe can use `pivot_longer` to move this information. To do so, we need to pass the variables we want to pivot to the `cols` argument, the name of the new variable to hold the colum names into `names_to`, and the name of the column to hold the pivoted data in `values_to`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmortality_long <- mortality |>\n  select(-indicator) |>  \n  pivot_longer(\n    cols = `1972`:`2020`,\n    names_to = \"year\",\n    values_to = \"child_mortality\"\n  ) |>\n  mutate(year = as.integer(year))\nmortality_long\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10,633 × 4\n   country country_code  year child_mortality\n   <chr>   <chr>        <int>           <dbl>\n 1 Aruba   ABW           1972              NA\n 2 Aruba   ABW           1973              NA\n 3 Aruba   ABW           1974              NA\n 4 Aruba   ABW           1975              NA\n 5 Aruba   ABW           1976              NA\n 6 Aruba   ABW           1977              NA\n 7 Aruba   ABW           1978              NA\n 8 Aruba   ABW           1979              NA\n 9 Aruba   ABW           1980              NA\n10 Aruba   ABW           1981              NA\n# ℹ 10,623 more rows\n```\n:::\n:::\n\n\nHere we mutate the years to be integers because they are characters when initially pivoted. \n\n\n### Pivoting longer with a column name prefix\n\nSometimes the column names have a prefix in front of the data that we want, like in the `spotify` data where the week columns are all `weekX` where `X` is the week number. We'd like to extract `X`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspotify\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 490 × 54\n   `Track Name`     Artist week1 week2 week3 week4 week5 week6 week7 week8 week9\n   <chr>            <chr>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1 The Box          Roddy…     1     1     1     1     1     1     1     1     1\n 2 ROXANNE          Arizo…     2     4     5     4     4     4     6     7     9\n 3 Yummy            Justi…     3     6    17    17    17    24    15    32    NA\n 4 Circles          Post …     4     7     9    10     7    10    11    10    17\n 5 BOP              DaBaby     5     5     7     5    11    12    18    18    32\n 6 Falling          Trevo…     6     8    10     7     6     8    10    11    18\n 7 Dance Monkey     Tones…     7    13    13    12    12    13    17    13    21\n 8 Bandit (with Yo… Juice…     8    11    14    14    15    20    27    26    42\n 9 Futsal Shuffle … Lil U…     9     9    19    21    24    32    40    49    NA\n10 everything i wa… Billi…    10    17    28     9     8    11    14    17    29\n# ℹ 480 more rows\n# ℹ 43 more variables: week10 <dbl>, week11 <dbl>, week12 <dbl>, week13 <dbl>,\n#   week14 <dbl>, week15 <dbl>, week16 <dbl>, week17 <dbl>, week18 <dbl>,\n#   week19 <dbl>, week20 <dbl>, week21 <dbl>, week22 <dbl>, week23 <dbl>,\n#   week24 <dbl>, week25 <dbl>, week26 <dbl>, week27 <dbl>, week28 <dbl>,\n#   week29 <dbl>, week30 <dbl>, week31 <dbl>, week32 <dbl>, week33 <dbl>,\n#   week34 <dbl>, week35 <dbl>, week36 <dbl>, week37 <dbl>, week38 <dbl>, …\n```\n:::\n:::\n\n\n\n\nWe can use the `names_prefix` arugment to do this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspotify |>\n  pivot_longer(\n    cols = c(-`Track Name`, -Artist),\n    names_to = \"week_of_year\",\n    values_to = \"rank\",\n    names_prefix = \"week\"\n  ) |>\n  mutate(\n    week_of_year = as.integer(week_of_year)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25,480 × 4\n   `Track Name` Artist      week_of_year  rank\n   <chr>        <chr>              <int> <dbl>\n 1 The Box      Roddy Ricch            1     1\n 2 The Box      Roddy Ricch            2     1\n 3 The Box      Roddy Ricch            3     1\n 4 The Box      Roddy Ricch            4     1\n 5 The Box      Roddy Ricch            5     1\n 6 The Box      Roddy Ricch            6     1\n 7 The Box      Roddy Ricch            7     1\n 8 The Box      Roddy Ricch            8     1\n 9 The Box      Roddy Ricch            9     1\n10 The Box      Roddy Ricch           10     1\n# ℹ 25,470 more rows\n```\n:::\n:::\n\n\n\n### Merging one data frame into another (joins)\n\nWe can take the variables from one data frame and put them into another data frame using the various join functions. If we think of the primary data frame as A and the donor data frame as B, then if we want to keep the rows of A the same and just import the columns of B, then we can use the `left_join`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  left_join(mortality_long)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(country, year)`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,704 × 8\n   country continent  year lifeExp    pop gdpPercap country_code child_mortality\n   <chr>   <fct>     <int>   <dbl>  <int>     <dbl> <chr>                  <dbl>\n 1 Afghan… Asia       1952    28.8 8.43e6      779. <NA>                     NA \n 2 Afghan… Asia       1957    30.3 9.24e6      821. <NA>                     NA \n 3 Afghan… Asia       1962    32.0 1.03e7      853. <NA>                     NA \n 4 Afghan… Asia       1967    34.0 1.15e7      836. <NA>                     NA \n 5 Afghan… Asia       1972    36.1 1.31e7      740. AFG                     291 \n 6 Afghan… Asia       1977    38.4 1.49e7      786. AFG                     262.\n 7 Afghan… Asia       1982    39.9 1.29e7      978. AFG                     231.\n 8 Afghan… Asia       1987    40.8 1.39e7      852. AFG                     198.\n 9 Afghan… Asia       1992    41.7 1.63e7      649. AFG                     166.\n10 Afghan… Asia       1997    41.8 2.22e7      635. AFG                     142.\n# ℹ 1,694 more rows\n```\n:::\n:::\n\n\nBy default this keeps all rows of A and any rows in A that do not appear in B give missing values for the newly imported columns of B. If we want only the rows that are in both A and B, we can use `inner_join`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  inner_join(mortality_long)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(country, year)`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,048 × 8\n   country continent  year lifeExp    pop gdpPercap country_code child_mortality\n   <chr>   <fct>     <int>   <dbl>  <int>     <dbl> <chr>                  <dbl>\n 1 Afghan… Asia       1972    36.1 1.31e7      740. AFG                    291  \n 2 Afghan… Asia       1977    38.4 1.49e7      786. AFG                    262. \n 3 Afghan… Asia       1982    39.9 1.29e7      978. AFG                    231. \n 4 Afghan… Asia       1987    40.8 1.39e7      852. AFG                    198. \n 5 Afghan… Asia       1992    41.7 1.63e7      649. AFG                    166. \n 6 Afghan… Asia       1997    41.8 2.22e7      635. AFG                    142. \n 7 Afghan… Asia       2002    42.1 2.53e7      727. AFG                    121. \n 8 Afghan… Asia       2007    43.8 3.19e7      975. AFG                     99.9\n 9 Albania Europe     1972    67.7 2.26e6     3313. ALB                     NA  \n10 Albania Europe     1977    68.9 2.51e6     3533. ALB                     NA  \n# ℹ 1,038 more rows\n```\n:::\n:::\n\n \n### Specifying the key variables for a join\n\nBy default, the join functions will merge data frames A and B based on the columns that have the same name in both data frames. This sometimes isn't what we want. For example, using the `nycflights13` package, we might want to merge the `flights` and `planes` data frames. Both of these data sets have a `year` variable but they mean different things in the two data frames (the year of the flights vs the year the plane was manufactured):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nycflights13)\nflights\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n:::\n\n```{.r .cell-code}\nplanes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,322 × 9\n   tailnum  year type              manufacturer model engines seats speed engine\n   <chr>   <int> <chr>             <chr>        <chr>   <int> <int> <int> <chr> \n 1 N10156   2004 Fixed wing multi… EMBRAER      EMB-…       2    55    NA Turbo…\n 2 N102UW   1998 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 3 N103US   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 4 N104UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 5 N10575   2002 Fixed wing multi… EMBRAER      EMB-…       2    55    NA Turbo…\n 6 N105UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 7 N107US   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 8 N108UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 9 N109UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n10 N110UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n# ℹ 3,312 more rows\n```\n:::\n:::\n\n\nIn this case, we want to specify what variable we want to do the merge with. Here, we want to merge based on `tailnum`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |>\n  left_join(planes, by = \"tailnum\") |>\n  select(year.x, tailnum, origin, dest, carrier, type, engine)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 336,776 × 7\n   year.x tailnum origin dest  carrier type                    engine   \n    <int> <chr>   <chr>  <chr> <chr>   <chr>                   <chr>    \n 1   2013 N14228  EWR    IAH   UA      Fixed wing multi engine Turbo-fan\n 2   2013 N24211  LGA    IAH   UA      Fixed wing multi engine Turbo-fan\n 3   2013 N619AA  JFK    MIA   AA      Fixed wing multi engine Turbo-fan\n 4   2013 N804JB  JFK    BQN   B6      Fixed wing multi engine Turbo-fan\n 5   2013 N668DN  LGA    ATL   DL      Fixed wing multi engine Turbo-fan\n 6   2013 N39463  EWR    ORD   UA      Fixed wing multi engine Turbo-fan\n 7   2013 N516JB  EWR    FLL   B6      Fixed wing multi engine Turbo-fan\n 8   2013 N829AS  LGA    IAD   EV      Fixed wing multi engine Turbo-fan\n 9   2013 N593JB  JFK    MCO   B6      Fixed wing multi engine Turbo-fan\n10   2013 N3ALAA  LGA    ORD   AA      <NA>                    <NA>     \n# ℹ 336,766 more rows\n```\n:::\n:::\n\n\nBecause both data sets had a `year` variable, the join function renames them to `year.x` in the first data frame and `year.y` for the second. We could rename them before merging to solve this problem. \n\n\n## Regression (Week 8)\n\n\n### Add binned means to a scatterplot\n\nYou can add binned means of the y-axis variable in a scatterplot using the `stat_summary_bin(fun = \"mean\")` function with your ggplot call:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(health, aes(x = steps_lag, y = weight)) +\n  geom_point(color = \"steelblue1\", alpha = 0.25) +\n  labs(\n    x = \"Steps on day prior (in 1000s)\",\n    y = \"Weight\",\n    title = \"Weight and Steps\"\n  ) +\n  stat_summary_bin(fun = \"mean\", color = \"indianred1\", size = 3,\n                   geom = \"point\", binwidth = 1)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 1 rows containing non-finite values (`stat_summary_bin()`).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n```\n:::\n\n::: {.cell-output-display}\n![](cheatsheet_files/figure-html/binned-1.png){width=672}\n:::\n:::\n\n\n\n\n### Running a regression (estimating the line of best fit)\n\nWe can estimate the line of best fit using the `lm` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- lm(weight ~ steps, data = health)\nfit\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = weight ~ steps, data = health)\n\nCoefficients:\n(Intercept)        steps  \n   170.5435      -0.2206  \n```\n:::\n:::\n\n\n\n### Extracting the vector of estimated regression coefficients\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoef(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)       steps \n170.5434834  -0.2205511 \n```\n:::\n:::\n\n\n\n### Obtaining unit-level statistics about the regression\n\nThe `broom` package has a number of functions that will allow you to extract information about the regression output from `lm()`. For example, if you want information about each unit such as the predicted/fitted value and the residual, you can use `augment`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(broom)\naugment(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 644 × 8\n   weight steps .fitted .resid    .hat .sigma   .cooksd .std.resid\n    <dbl> <dbl>   <dbl>  <dbl>   <dbl>  <dbl>     <dbl>      <dbl>\n 1   168  17.5     167.  1.31  0.00368   4.69 0.000146       0.281\n 2   169. 18.4     166.  2.62  0.00463   4.69 0.000730       0.560\n 3   168  19.6     166.  1.78  0.00609   4.69 0.000444       0.381\n 4   167. 10.4     168. -1.05  0.00217   4.69 0.0000547     -0.224\n 5   168. 18.7     166.  1.78  0.00496   4.69 0.000362       0.381\n 6   168.  9.14    169. -0.728 0.00296   4.69 0.0000359     -0.156\n 7   166.  8.69    169. -2.33  0.00331   4.69 0.000412      -0.498\n 8   168. 13.8     167.  0.911 0.00165   4.69 0.0000313      0.195\n 9   169  11.9     168.  1.08  0.00165   4.69 0.0000439      0.231\n10   169. 24.6     165.  4.19  0.0155    4.68 0.00639        0.902\n# ℹ 634 more rows\n```\n:::\n:::\n\n\n\n\n### Obtaining overall information about the model fitted\n\nThe `glance` function will give you some high-level information about the regression, including the $R^2$:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglance(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 12\n  r.squared adj.r.squared sigma statistic    p.value    df logLik   AIC   BIC\n      <dbl>         <dbl> <dbl>     <dbl>      <dbl> <dbl>  <dbl> <dbl> <dbl>\n1    0.0332        0.0317  4.68      22.1 0.00000323     1 -1907. 3820. 3834.\n# ℹ 3 more variables: deviance <dbl>, df.residual <int>, nobs <int>\n```\n:::\n:::\n\n\n\nYou can also access the $R^{2}$ using the `summary()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(fit)$r.squared\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.03322261\n```\n:::\n:::\n\n\n### Running a multiple regression\n\nYou can fit a regression with multiple predictors by putting a `+` between them on the right-hand side of the formula:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmult.fit <- lm(seat_change ~ approval + rdi_change,\n               data = midterms)\nmult.fit\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = seat_change ~ approval + rdi_change, data = midterms)\n\nCoefficients:\n(Intercept)     approval   rdi_change  \n   -117.226        1.526        3.217  \n```\n:::\n:::\n",
    "supporting": [
      "cheatsheet_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}